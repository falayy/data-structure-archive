# Data Structures & Algorithms Learning Path

**Start Date:** January 6, 2026  
**Goal:** Master DSA fundamentals through advanced topics with structured daily practice

---

## ðŸ“‹ Learning Order

### Phase 1: Foundations (Weeks 1-4)

#### Week 1: Complexity & Arrays
1. **Big O Notation & Complexity Analysis**
   - Time complexity
   - Space complexity
   - Best, average, worst cases

2. **Arrays**
   - Array manipulation
   - Multi-dimensional arrays
   - In-place operations
   - Common operations (reverse, rotate, search)

3. **Strings**
   - String manipulation
   - Character arrays
   - Common string operations

#### Week 2: Hash Tables & Two Pointers
4. **Hash Tables / Hash Maps**
   - Hash functions
   - Collision handling
   - Hash map vs hash set
   - Frequency counting patterns

5. **Two Pointers Technique**
   - Left-right pointers (converging)
   - Same direction pointers
   - Fast and slow pointers
   - Applications in sorted arrays

6. **Sliding Window**
   - Fixed-size window
   - Variable-size window
   - Substring/subarray problems

#### Week 3: Linked Lists
7. **Singly Linked Lists**
   - Basic operations (insert, delete, search)
   - Pointer manipulation
   - Dummy nodes
   - Reversing

8. **Doubly Linked Lists & Circular Lists**
   - Bidirectional traversal
   - Circular linked list applications

9. **Fast & Slow Pointers (Floyd's Cycle Detection)**
   - Cycle detection
   - Finding middle element
   - Finding cycle start

#### Week 4: Stacks & Queues
10. **Stacks**
    - LIFO principle
    - Stack implementations
    - Matching problems (parentheses)
    - Monotonic stack

11. **Queues**
    - FIFO principle
    - Queue implementations
    - Circular queue
    - Deque (double-ended queue)

12. **Basic Recursion**
    - Base case and recursive case
    - Call stack understanding
    - Simple recursive problems

---

### Phase 2: Trees & Advanced Recursion (Weeks 5-8)

#### Week 5: Binary Trees Fundamentals
13. **Binary Trees Basics**
    - Tree terminology (root, leaf, height, depth)
    - Tree properties
    - Basic operations

14. **Tree Traversals - DFS**
    - Inorder (Left â†’ Root â†’ Right)
    - Preorder (Root â†’ Left â†’ Right)
    - Postorder (Left â†’ Right â†’ Root)
    - Recursive and iterative implementations

15. **Tree Traversals - BFS**
    - Level-order traversal
    - Using queue for BFS
    - Tracking levels

#### Week 6: Binary Search Trees
16. **Binary Search Trees (BST)**
    - BST property (left < root < right)
    - Search, insert, delete operations
    - BST validation

17. **BST Applications**
    - Kth smallest/largest element
    - Range queries
    - BST to sorted array

18. **Recursion Deep Dive**
    - Advanced recursion patterns
    - Divide and conquer
    - Memoization introduction

#### Week 7: More Tree Problems
19. **Tree Construction & Modification**
    - Building trees from traversals
    - Tree serialization/deserialization
    - Lowest Common Ancestor

20. **Tree Properties**
    - Height and depth calculations
    - Diameter of tree
    - Balanced trees
    - Symmetric trees

#### Week 8: Binary Search
21. **Binary Search Fundamentals**
    - Binary search algorithm
    - Search in sorted array
    - Finding boundaries (first/last occurrence)

22. **Binary Search Variations**
    - Search in rotated sorted array
    - Search in 2D matrix
    - Binary search on answer space
    - Peak finding

---

### Phase 3: Graphs (Weeks 9-11)

#### Week 9: Graph Fundamentals
23. **Graph Representations**
    - Graph terminology (vertex, edge, directed, undirected)
    - Adjacency list
    - Adjacency matrix
    - Edge list

24. **Graph BFS (Breadth-First Search)**
    - BFS algorithm
    - Shortest path in unweighted graphs
    - Level-by-level exploration
    - Connected components

25. **Graph DFS (Depth-First Search)**
    - DFS algorithm (recursive and iterative)
    - Path finding
    - Cycle detection
    - Connected components

#### Week 10: Advanced Graph Algorithms
26. **Topological Sort**
    - DAG (Directed Acyclic Graph)
    - Kahn's algorithm (BFS)
    - DFS approach
    - Applications (course prerequisites, build order)

27. **Union-Find (Disjoint Set)**
    - Find and union operations
    - Path compression
    - Union by rank
    - Cycle detection in undirected graphs

#### Week 11: Weighted Graph Algorithms
28. **Dijkstra's Algorithm**
    - Shortest path in weighted graphs
    - Priority queue implementation
    - Applications

29. **Minimum Spanning Tree**
    - Kruskal's algorithm
    - Prim's algorithm
    - Applications

---

### Phase 4: Heaps & Dynamic Programming (Weeks 12-15)

#### Week 12: Heaps
30. **Heaps / Priority Queues**
    - Min heap and max heap
    - Heap property
    - Heapify operation
    - Insert and extract operations

31. **Heap Applications**
    - Top K elements
    - Kth largest/smallest
    - Median finding (two heaps)
    - Merge K sorted lists

#### Week 13: Dynamic Programming Foundations
32. **1D Dynamic Programming**
    - Optimal substructure
    - Overlapping subproblems
    - Memoization (top-down)
    - Tabulation (bottom-up)
    - Classic problems: Fibonacci, Climbing Stairs, House Robber

33. **DP Pattern Recognition**
    - Linear sequence problems
    - Decision at each step
    - State transitions

#### Week 14: 2D Dynamic Programming
34. **2D DP Fundamentals**
    - Grid problems
    - String matching
    - Two sequence problems

35. **Classic 2D DP Problems**
    - Longest Common Subsequence
    - Edit Distance
    - Unique Paths
    - Coin Change variations

#### Week 15: Advanced DP
36. **Advanced DP Patterns**
    - Knapsack problems (0/1, unbounded)
    - Partition problems
    - Longest Increasing Subsequence
    - Palindrome problems

37. **DP Optimization Techniques**
    - Space optimization
    - State compression
    - Kadane's algorithm

---

### Phase 5: Advanced Topics (Weeks 16-20)

#### Week 16: Backtracking
38. **Backtracking Fundamentals**
    - Backtracking template
    - Choice, constraint, goal
    - Pruning invalid paths

39. **Backtracking Applications**
    - Permutations and combinations
    - Subset problems
    - N-Queens
    - Sudoku solver
    - Word search

#### Week 17: Tries & Advanced Strings
40. **Tries (Prefix Trees)**
    - Trie structure
    - Insert, search, startsWith operations
    - Autocomplete
    - Word search optimization

41. **String Algorithms**
    - KMP algorithm
    - Rabin-Karp algorithm
    - Longest palindromic substring
    - String matching

#### Week 18: Advanced Data Structures
42. **Segment Trees**
    - Range queries
    - Range updates
    - Lazy propagation

43. **Fenwick Tree (Binary Indexed Tree)**
    - Range sum queries
    - Point updates
    - Applications

#### Week 19: Specialized Patterns
44. **Monotonic Stack/Queue**
    - Next greater/smaller element
    - Largest rectangle in histogram
    - Sliding window maximum

45. **Intervals**
    - Merge intervals
    - Insert interval
    - Meeting rooms
    - Sweep line algorithm

46. **Bit Manipulation**
    - Basic bit operations
    - Common bit tricks
    - XOR properties
    - Subset generation with bits

#### Week 20: Math & Miscellaneous
47. **Number Theory**
    - Prime numbers
    - GCD and LCM
    - Modular arithmetic
    - Fast exponentiation

48. **Math Problems**
    - Combinatorics
    - Probability
    - Matrix operations

49. **Greedy Algorithms**
    - Greedy choice property
    - Interval scheduling
    - Activity selection
    - When greedy works vs DP

50. **Design Problems**
    - LRU Cache
    - LFU Cache
    - Design data structures
    - API design considerations

---

## ðŸ“Š Weekly Practice Guidelines

### Daily Commitment
- **2 hours per day** (or 1.5 hours minimum)
- **5-6 days per week**
- Focus on understanding over speed initially

### Problem Distribution per Topic
- **Easy:** 5-8 problems
- **Medium:** 5-10 problems
- **Hard:** 2-5 problems (exposure, learning focused)

### Weekly Review
- Review all problems from the week
- Redo 2-3 difficult problems
- Update pattern notes/cheat sheet
- Identify weak areas

---

## ðŸŽ¯ Milestones

### Month 1 (End of Week 4)
- Master arrays, strings, hash tables
- Comfortable with two pointers and sliding window
- Understand linked lists, stacks, queues
- Solve 70%+ of Easy problems independently

### Month 2 (End of Week 8)
- Master all tree traversals
- Comfortable with BST operations
- Strong recursion skills
- Binary search mastery
- Solve 90%+ of Easy, 30%+ of Medium

### Month 3 (End of Week 12)
- Master graph algorithms (BFS, DFS, topological sort)
- Understand Union-Find
- Comfortable with heaps
- Solve 50%+ of Medium problems

### Month 4 (End of Week 16)
- Strong DP foundation (1D and 2D)
- Understand backtracking
- Trie implementation and usage
- Solve 60%+ of Medium problems

### Month 5 (End of Week 20)
- Advanced topics exposure
- Pattern recognition mastery
- Ready for most technical interviews
- Solve 65%+ of Medium, attempt Hard problems

---

## ðŸ“š Recommended Resources

### Practice Platforms
- **LeetCode** (primary)
- **NeetCode.io** (curated lists with video solutions)
- **HackerRank** (additional practice)
- **Codeforces** (competitive programming)

### Learning Resources
- **Books:**
  - "Cracking the Coding Interview" - Gayle Laakmann McDowell
  - "Introduction to Algorithms" - CLRS
  - "Elements of Programming Interviews"

- **Video Resources:**
  - NeetCode (YouTube)
  - Abdul Bari (YouTube)
  - Back to Back SWE (YouTube)
  - CS Dojo (YouTube)

- **Visualization:**
  - VisuAlgo.net
  - Algorithm Visualizer
  - Data Structure Visualizations (USF)

### Online Courses
- MIT OpenCourseWare (6.006)
- Princeton Algorithms (Coursera)
- Stanford Algorithms Specialization (Coursera)

---

## ðŸ’¡ Study Tips

### Do's âœ…
- Understand the pattern, not just the solution
- Practice drawing out solutions on paper
- Time yourself on problems
- Explain your approach out loud
- Review optimal solutions even if you solved it
- Keep a pattern cheat sheet
- Join study communities (r/leetcode, Discord servers)

### Don'ts âŒ
- Don't just memorize solutions
- Don't skip Easy problems
- Don't give up after 5 minutes (try for 30+ minutes)
- Don't jump to Hard problems too early
- Don't skip review days
- Don't study 10 hours one day then nothing for a week

---

## ðŸ”„ Problem-Solving Framework

### Step 1: Understand (5 minutes)
- Read problem carefully
- Identify inputs and outputs
- Consider edge cases
- Ask clarifying questions

### Step 2: Plan (5-10 minutes)
- Identify the pattern
- Think of similar problems
- Consider brute force first
- Sketch out approach

### Step 3: Implement (15-20 minutes)
- Write clean, readable code
- Use meaningful variable names
- Comment complex logic
- Handle edge cases

### Step 4: Test (5 minutes)
- Test with example cases
- Test edge cases
- Walk through your code

### Step 5: Optimize (5-10 minutes)
- Can you improve time complexity?
- Can you reduce space complexity?
- Are there any redundant operations?

### Step 6: Reflect (5 minutes)
- What pattern did you use?
- What did you learn?
- Could you solve similar problems?
- What would you do differently?

---

## ðŸ“ˆ Tracking Progress

### Daily
- Log problems solved
- Note difficulty and time taken
- Record patterns learned
- Write key insights

### Weekly
- Count problems by difficulty
- Identify strongest/weakest patterns
- Review mistake patterns
- Adjust study plan if needed

### Monthly
- Assess against milestones
- Comprehensive pattern review
- Mock interview practice
- Celebrate progress!

---

## ðŸŽ“ After Completing This Path

You will be able to:
- âœ… Recognize patterns in new problems instantly
- âœ… Solve most Easy and Medium LeetCode problems
- âœ… Approach Hard problems with structured thinking
- âœ… Pass technical interviews at most tech companies
- âœ… Continue learning advanced topics independently

### Next Steps
1. **Practice Regularly** - Solve 3-5 problems per week to maintain skills
2. **Mock Interviews** - Use Pramp, Interviewing.io
3. **Contribute to Open Source** - Apply skills in real projects
4. **Mentor Others** - Teaching reinforces your knowledge
5. **Stay Updated** - Learn new algorithms and techniques


**Start Date:** January 6, 2026  
**Duration:** ~20 weeks (5 months)  
**Outcome:** Interview-ready for software engineering roles

*Good luck on your learning journey! ðŸš€*